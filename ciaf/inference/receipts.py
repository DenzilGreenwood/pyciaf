"""
Inference receipt implementation for the CIAF framework.

This module contains the InferenceReceipt class which provides verifiable records
of AI model inferences, linking them to specific training snapshots and data provenance.
It also includes the ZKEConnections class for managing connections of receipts with tamper detection.

Created: 2025-09-09
Last Modified: 2025-09-11
Author: Denzil James Greenwood
Version: 1.0.0
"""

from datetime import datetime
from typing import List, Optional

from ..core import CryptoUtils


class InferenceReceipt:
    """
    Represents a verifiable receipt for an AI model inference.
    Links the inference to specific training data and model versions for full traceability.
    Supports connections to previous receipts for tamper-evident audit trails.
    """

    def __init__(
        self,
        query: str,
        ai_output: str,
        model_version: str,
        training_snapshot_id: str,
        training_snapshot_merkle_root: str,
        prev_receipt_hash: Optional[str] = None,
    ):
        """
        Initializes an InferenceReceipt.

        Args:
            query: The input query/prompt given to the AI model.
            ai_output: The output/response generated by the AI model.
            model_version: Version identifier of the model used.
            training_snapshot_id: ID of the training snapshot used for this model.
            training_snapshot_merkle_root: Merkle root hash from the training snapshot.
            prev_receipt_hash: Optional hash of the previous receipt in the connections.
        """
        self.query = query
        self.ai_output = ai_output
        self.model_version = model_version
        self.training_snapshot_id = training_snapshot_id
        self.training_snapshot_merkle_root = training_snapshot_merkle_root
        self.prev_receipt_hash = prev_receipt_hash
        self.timestamp = datetime.now().isoformat()
        self.crypto_utils = CryptoUtils()

        # Compute receipt hash including previous receipt hash for connections
        self.receipt_hash = self._compute_hash()
        print(f"Inference Receipt '{self.receipt_hash}' created.")

    def _compute_hash(self) -> str:
        """
        Compute the hash for this receipt.

        Includes all receipt fields including the previous receipt hash to ensure
        tamper-evident connections.

        Returns:
            SHA256 hash of the receipt contents.
        """
        hash_components = [
            self.query,
            self.ai_output,
            self.model_version,
            self.training_snapshot_id,
            self.training_snapshot_merkle_root,
            self.timestamp,
        ]

        if self.prev_receipt_hash:
            hash_components.append(self.prev_receipt_hash)

        combined_string = "-".join(hash_components)
        return self.crypto_utils.sha256_hash(combined_string.encode("utf-8"))

    @classmethod
    def issue(
        cls,
        query: str,
        ai_output: str,
        model_version: str,
        training_snapshot_id: str,
        training_snapshot_merkle_root: str,
        prev_receipt: Optional["InferenceReceipt"] = None,
    ) -> "InferenceReceipt":
        """
        Factory method to create a new inference receipt with optional connections.

        Args:
            query: The input query/prompt given to the AI model.
            ai_output: The output/response generated by the AI model.
            model_version: Version identifier of the model used.
            training_snapshot_id: ID of the training snapshot used for this model.
            training_snapshot_merkle_root: Merkle root hash from the training snapshot.
            prev_receipt: Optional previous receipt to connect to.

        Returns:
            New InferenceReceipt instance.
        """
        prev_hash = prev_receipt.receipt_hash if prev_receipt else None
        return cls(
            query=query,
            ai_output=ai_output,
            model_version=model_version,
            training_snapshot_id=training_snapshot_id,
            training_snapshot_merkle_root=training_snapshot_merkle_root,
            prev_receipt_hash=prev_hash,
        )

    def to_json(self) -> dict:
        """
        Serializes the InferenceReceipt to a JSON-compatible dictionary.

        Returns:
            Dictionary representation of the receipt.
        """
        return {
            "receipt_hash": self.receipt_hash,
            "query": self.query,
            "ai_output": self.ai_output,
            "model_version": self.model_version,
            "training_snapshot_id": self.training_snapshot_id,
            "training_snapshot_merkle_root": self.training_snapshot_merkle_root,
            "prev_receipt_hash": self.prev_receipt_hash,
            "timestamp": self.timestamp,
        }

    @classmethod
    def from_json(cls, json_data: dict):
        """
        Reconstructs an InferenceReceipt from JSON data.

        Args:
            json_data: Dictionary representation from to_json().

        Returns:
            Reconstructed InferenceReceipt instance.
        """
        receipt = cls.__new__(cls)
        receipt.receipt_hash = json_data["receipt_hash"]
        receipt.query = json_data["query"]
        receipt.ai_output = json_data["ai_output"]
        receipt.model_version = json_data["model_version"]
        receipt.training_snapshot_id = json_data["training_snapshot_id"]
        receipt.training_snapshot_merkle_root = json_data[
            "training_snapshot_merkle_root"
        ]
        receipt.prev_receipt_hash = json_data.get("prev_receipt_hash")
        receipt.timestamp = json_data["timestamp"]
        receipt.crypto_utils = CryptoUtils()
        return receipt

    def verify_integrity(self) -> bool:
        """
        Verifies the integrity of the receipt by checking the hash.

        Returns:
            True if the receipt hash is valid, False otherwise.
        """
        expected_hash = self._compute_hash()
        return expected_hash == self.receipt_hash


class ZKEConnections:
    """
    Manages a connections of inference receipts with tamper-evident linking.

    This class simplifies issuing new receipts and verifying the integrity
    of the entire connections. Each receipt is linked to the previous one through
    cryptographic hashing, making tampering detectable.
    """

    def __init__(self) -> None:
        """Initialize an empty receipt connections."""
        self.receipts: List[InferenceReceipt] = []

    def add_receipt(
        self,
        query: str,
        ai_output: str,
        model_version: str,
        training_snapshot_id: str,
        training_snapshot_merkle_root: str,
    ) -> InferenceReceipt:
        """
        Issue a new receipt and append it to the connections.

        Args:
            query: The input query/prompt given to the AI model.
            ai_output: The output/response generated by the AI model.
            model_version: Version identifier of the model used.
            training_snapshot_id: ID of the training snapshot used for this model.
            training_snapshot_merkle_root: Merkle root hash from the training snapshot.

        Returns:
            The newly created and connected InferenceReceipt.
        """
        prev_receipt = self.receipts[-1] if self.receipts else None
        receipt = InferenceReceipt.issue(
            query=query,
            ai_output=ai_output,
            model_version=model_version,
            training_snapshot_id=training_snapshot_id,
            training_snapshot_merkle_root=training_snapshot_merkle_root,
            prev_receipt=prev_receipt,
        )
        self.receipts.append(receipt)
        return receipt

    def verify_connections(self) -> bool:
        """
        Verify the integrity of all receipts in the connections.

        Checks that:
        1. Each receipt's hash is valid
        2. Each receipt's prev_receipt_hash matches the previous receipt's hash
        3. The connections structure is consistent

        Returns:
            True if the entire connections is valid, False otherwise.
        """
        if not self.receipts:
            return True  # Empty connections is valid

        prev_hash: Optional[str] = None
        for i, receipt in enumerate(self.receipts):
            # Verify receipt's internal integrity
            if not receipt.verify_integrity():
                print(f"Connections verification failed: Receipt {i} has invalid hash")
                return False

            # Verify connecting
            if receipt.prev_receipt_hash != prev_hash:
                print(f"Connections verification failed: Receipt {i} has incorrect prev_hash")
                return False

            prev_hash = receipt.receipt_hash

        return True

    def get_connections_summary(self) -> dict:
        """
        Get a summary of the receipt connections.

        Returns:
            Dictionary with connections statistics and information.
        """
        if not self.receipts:
            return {
                "total_receipts": 0,
                "connections_valid": True,
                "first_receipt": None,
                "last_receipt": None,
                "model_versions_used": [],
            }

        model_versions = list(set(r.model_version for r in self.receipts))

        return {
            "total_receipts": len(self.receipts),
            "connections_valid": self.verify_connections(),
            "first_receipt": self.receipts[0].receipt_hash,
            "last_receipt": self.receipts[-1].receipt_hash,
            "model_versions_used": model_versions,
            "time_span": {
                "start": self.receipts[0].timestamp,
                "end": self.receipts[-1].timestamp,
            },
        }

    def to_json(self) -> dict:
        """
        Serialize the entire connections to JSON.

        Returns:
            Dictionary representation of the connections.
        """
        return {
            "receipts": [receipt.to_json() for receipt in self.receipts],
            "connections_summary": self.get_connections_summary(),
        }

    @classmethod
    def from_json(cls, json_data: dict) -> "ZKEConnections":
        """
        Reconstruct a ZKEConnections from JSON data.

        Args:
            json_data: Dictionary representation from to_json().

        Returns:
            Reconstructed ZKEConnections instance.
        """
        connections = cls()
        for receipt_data in json_data["receipts"]:
            receipt = InferenceReceipt.from_json(receipt_data)
            connections.receipts.append(receipt)
        return connections
